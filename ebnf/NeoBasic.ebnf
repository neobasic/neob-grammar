(*
The MIT License (MIT)
Copyright (c) 2025 [WE THE DEVS].

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *)

(*
 * Project      : ANTLR4 lexer grammar for NeoBASIC programming language.
 *                https://github.com/neobasic
 * Developed by : Raul Bras, @teknolista.
 *)

(* SOURCE CODE ORGANIZATION OF NEO PROGRAM *)

NeoProgram = OneLinerProgram | SourceCodeProgram .

SourceCodeProgram = ( ProcessProgram | NotabeneProgram ) EOF .

ProcessProgram = IdentificationDivision EnvironmentDivision ProcessingDivision TestingDivision .

NotabeneProgram =  IdentificationDivision NoteDivision BookDivision .

OneLinerProgram = Statement .


(* ------------------------------------------------------------------------- *)


(* IDENTIFICATION DIVISION *)

IdentificationDivision = { IdentificationStatement EOL } .

IdentificationStatement = IdentityStatement 
                        | CommentedStatement .

IdentityStatement = { DirectiveStatement }
                    ( ModuleSentence | AlgorithmSentence | NotabeneSentence ) .


(* UNIT PROCESS PROGRAMS *)

ModuleSentence = MODULE ModuleName .

ModuleName = NamespaceIdentifier .


(* ALGORITH PROCESS PROGRAMS *)

AlgorithmSentence = ALGORITHM AlgorithmName .

AlgorithmName = Identifier .


(* NOTA BENE PROGRAMS *)

NotabeneSentence = NOTABENE NotabeneName NotabeneVersion .

NotabeneName = NamespaceIdentifier .

NotabeneVersion = NumberLiteral .


(* ------------------------------------------------------------------------- *)


(* ENVIRONMENT DIVISION *)

EnvironmentDivision = { EnvironmentStatement EOL } .

EnvironmentStatement = UseSentence
                     | InterfaceSentence
                     | IncludeSentence
                     | CommentedStatement .


(* USE SENTENCE *)

UseSentence = USE ( UseDeclares | UseSuite ) .

UseSuite = EOL Indent UseDeclaresList Dedent .

UseDeclaresList = UseDeclares { EOL UseDeclares } .

UseDeclares = UseDeclare { "," UseDeclare } .

UseDeclare = ModuleName
           | ModuleMember
           | ModuleAsClause
           | ModuleOfClause .

ModuleMember = NamespaceIdentifier .

ModuleAsClause = ModuleName AS Identifier .

ModuleOfClause = Identifiers OF ModuleName . 


(* INCLUDE SENTENCE *)

IncludeSentence = INCLUDE ( IncludeDeclares | IncludeSuite ) . 

IncludeSuite = EOL Indent IncludeDeclaresList Dedent .

IncludeDeclaresList = IncludeDeclares { EOL IncludeDeclares } . 

IncludeDeclares = IncludeDeclare { "," IncludeDeclare } .

IncludeDeclare = ShellExpression
               | IncludeAsClause .

IncludeAsClause = ShellExpression AS Identifier .


(* INTERFACE SENTENCE *)

InterfaceSentence = INTERFACE SymbolIdentifier ( ApiClause | MixinSentence )
                    InterfaceBody .

ApiClause = ":" ApiType StringLiteral .

ApiType = SOCKET | HTTP | HTTPS | REST | SOAP | GRPC | AMQP | FTP | SMTP | IMAP | POP3 .

InterfaceBody = EOL Indent InterfaceMemberDeclaresList Dedent .

InterfaceMemberDeclaresList = InterfaceMemberDeclares { EOL InterfaceMemberDeclares } .

InterfaceMemberDeclares = InterfaceMemberDeclare { "," InterfaceMemberDeclare } .

InterfaceMemberDeclare = MixinSentence
                       | RpcMethodDeclare
                       | ExternMethodDeclare .

MixinSentence = MixinOperator Types .

RpcMethodDeclare = RPC SymbolIdentifier RpcParameters RpcResult .

RpcParameters = "(" [ Types ] ")" .

RpcResult = Type .

ExternMethodDeclare = EXTERN SymbolIdentifier ExternParameters [ ExternResult ] [ ExternBind ] .

ExternParameters = "(" [ Types ] ")" .

ExternResult = Type .

ExternBind = MonadBindOperador Identifier .


(* ------------------------------------------------------------------------- *)


(* PROCESSING DIVISION *)

ProcessingDivision = { ProcessingStatement EOL } .

ProcessingStatement = TopLevelSentence 
                    | CommentedStatement .


(* ------------------------------------------------------------------------- *)


(* TESTING DIVISION *)

TestingDivision = { TestingStatement EOL } .

TestingStatement = TopLevelSentence 
                 | CommentedStatement .


(* ------------------------------------------------------------------------- *)


(* NOTE DIVISION *)

NoteDivision = { NoteStatement EOL } .

NoteStatement = CommentedStatement .  (* TODO: ... *)


(* ------------------------------------------------------------------------- *)


(* BOOK DIVISION *)

BookDivision = { BookStatement EOL } .

BookStatement = CommentedStatement .  (* TODO: ... *)


(* ------------------------------------------------------------------------- *)


(* STEREOTYPES & GENERICS *)

StereotypesList = [ AtomStereotypes ]
                  [ GenericsStereotype ] .

GenericsStereotype = "<<" TypeParameters ">>" .

AtomStereotypes = AtomStereotype { [ EOL ] AtomStereotype } .

AtomStereotype = AtomIdentifier [ TaggedValuePairs ]
               | AspectIdentifier [ TaggedValuePairs ]
               .

TaggedValuePairs = TaggedValuePair { "," TaggedValuePair } .

TaggedValuePair = [ Identifier "=" ] Expression .


(* COMMENTS *)

CommentedStatement = CommentStatement
                   | DirectiveStatement
                   | LookupStatement
                   | TestStatement
                   .

Comment = "#" .

LineCommentBegin = Comment .
LineCommentEnd   = EOL .
LineComment      = LineCommentBegin { UnicodePrintable } LineCommentEnd .

BlockCommentBegin = Comment Comment .
BlockCommentEnd   = BlockCommentBegin .
BlockComment      = BlockCommentBegin { Hashtag | UnicodePrintable | EOL } BlockCommentEnd .

DocumentationCommentBegin = Comment Comment Comment .
DocumentationCommentEnd   = DocumentationCommentBegin .
DocumentationComment      = DocumentationCommentBegin { Hashtag | UnicodePrintable | EOL } DocumentationCommentEnd .

CommentContent = LineComment | BlockComment | DocumentationComment .

CommentStatement = CommentContent 
                 | Statement CommentContent .


(* MAGIC COMMENT: HASHTAG *)

Hashtag = Comment Tag { "/" Tag } .


(* MAGIC COMMENT: DIRECTIVE *)

Shebang = Comment "!" .

ShebangInterpreter = Shebang InterpreterPath [ InterpreterArguments ] .

InterpreterPath = FileSystemPath .

InterpreterArguments = { UnicodePrintable } .

PragmaStatement = Shebang { UnicodePrintable } .

DirectiveStatement = ShebangInterpreter
                   | PragmaStatement .


(* MAGIC COMMENT: SHELL LOOKUP *)

Sherlock = Comment UnicodeShell .

LookupStatement = Sherlock Expressions .


(* MAGIC COMMENT: CANARY TESTING *)

Woodstock = Comment "?" .

AssertionTest = Woodstock AssertionExpression .

AssertionExpression = ( Expressions | Statement ) [ "!" [ Expression ] ] .

UnitTest = Woodstock TestSentence .

TestSentence = [ TestDiretives ]
               UnitClause
               [ FromClause ]
               [ OnceClause ]
               [ DataClause ]
               [ CallClause ]
               [ HideClause ]
               [ ShowClause ]
               [ IntoClause ]
               [ PassClause ]
               [ PastClause ]
               [ FailClause ] .

TestDiretives = [ TaggedValuePairs ] EOL .

UnitClause = UNIT [ StringLiteral ] [ StatementSuite ] EOL .

FromClause = FROM [ Expressions | StatementSuite ] EOL .

OnceClause = ONCE [ Expressions | StatementSuite ] EOL .

DataClause = DATA DataSuite EOL .

DataSuite = EOL Indent DataList Dedent .

DataList = { Expression { "|" Expression } EOL  } .

CallClause = CALL [ Expressions | StatementSuite ] EOL .

HideClause = HIDE [ Expressions | StatementSuite ] EOL .

ShowClause = SHOW [ Expressions | StatementSuite ] EOL .

IntoClause = INTO [ Expressions | StatementSuite ] EOL .

PassClause = PASS [ Expressions | StatementSuite ] EOL .

PastClause = PAST [ Expressions | StatementSuite ] EOL .

FailClause = FAIL [ Expressions | StatementSuite ] EOL .

TestStatement = AssertionTest | UnitTest .


(* ------------------------------------------------------------------------- *)


(* TOP LEVEL SENTENCES *)

TopLevelSentence = StereotypesList TopLevelSentence
                 | TypeSentence
                 | DefSentence
                 | DefnSentence
                 | UndefSentence
                 | ConstSentence
                 | ValSentence
                 | VarSentence
                 | FuncSentence
                 | FactSentence
                 | FmapSentence
                 | FeedSentence
                 | SubSentence
                 | EventSentence
                 | StructSentence
                 | EnumSentence
                 | ProtoSentence
                 | TraitSentence
                 | ClassSentence .


(* TYPE SENTENCE *)

TypeSentence = TYPE ( TypeDeclare | TypeSuite ) .

TypeSuite = EOL Indent TypeDeclareList Dedent .

TypeDeclareList = TypeDeclare { EOL TypeDeclare } .

TypeDeclare = SymbolIdentifier [ GenericTypes ] [ ":" | AS | SubtypeOperator | MixinOperator ] Type [ "=" TypeName ] [ MonadBody ] .

MonadBody = EOL Indent MonadMemberDeclaresList Dedent .

MonadMemberDeclaresList = MonadMemberDeclares { EOL MonadMemberDeclares } .

MonadMemberDeclares = MonadMemberDeclare { "," MonadMemberDeclare } .

MonadMemberDeclare = MixinSentence
                   | TopLevelSentence
                   | MonadicValueDeclare .

MonadicValueDeclare = SymbolIdentifier [ "(" TypeParameter ")" ] [ "=" Expression ] .


(* FACT SENTENCE *)

FactSentence = FACT SymbolIdentifier TypeParameters LambdaImpliesOperator Expression .


(* DEF SENTENCE *)

DefSentence = DEF ( DefDeclare | DefSuite ) .

DefSuite = EOL Indent DefDeclareList Dedent .

DefDeclareList = DefDeclare { EOL DefDeclare } .

DefDeclare = Identifier [ LambdaImpliesOperator Expression ] .


(* DEFN SENTENCE *)

DefnSentence = DEFN ( DefnDeclare | DefnSuite ) .

DefnSuite = EOL Indent DefnDeclareList Dedent .

DefnDeclareList = DefnDeclare { EOL DefnDeclare } .

DefnDeclare = Identifier ProcParameters LambdaImpliesOperator Expression .


(* UNDEF SENTENCE *)

UndefSentence = UNDEF ( UndefDeclare | UndefSuite ) .

UndefSuite = EOL Indent UndefDeclareList Dedent .

UndefDeclareList = UndefDeclare { EOL UndefDeclare } . 

UndefDeclare = Identifier .


(* CONST SENTENCE *)

ConstSentence = CONST ( VarDeclares | VarSuite ) .


(* VAL SENTENCE *)

ValSentence = VAL ( VarDeclares | VarSuite ) . 


(* VAR SENTENCE *)

VarSentence = VAR ( VarDeclares | VarSuite ) .

VarSuite = EOL Indent VarDeclaresList Dedent .

VarDeclaresList = VarDeclares { EOL VarDeclares } .

VarDeclares = VarDeclare { "," VarDeclare } .

VarDeclare = SymbolIdentifiers [ Type ] [ DeclareAssignment | HeredocLiteral ] .

DeclareAssignment = SingleAssignmentOperator Expressions .


(* FUNC SENTENCE *) 

FuncSentence = FUNC FunctionName [ GenericTypes ] ProcParameters ProcResults ( GuardsSuite | ProcBody ) .

FunctionName = SymbolIdentifier [ SubtypeOperator Identifier ] .

ProcParameters = "(" [ ParmDeclares ] ")"
               | ParmDeclare "=>" { ParmDeclare "=>" } .

ParmDeclares = ParmDeclare { "," ParmDeclare } .

ParmDeclare = [ ParmIdentifiers ] Type [ "=" Expression ] .

ParmIdentifiers = ParmIdentifier { "," ParmIdentifier } .

ParmIdentifier = [ AtomStereotypes ] [ PrefixParmModifier ] Identifier .

ProcResults = ResultDeclares | "(" ResultDeclares ")" .

ResultDeclares = ResultDeclare { "," ResultDeclare } .

ResultDeclare = [ ResultIdentifiers ] Type .

ResultIdentifiers = Identifiers .

GuardsSuite = EOL GuardsClause .

ProcBody = LambdaImpliesOperator Expressions
         | LambdaImpliesOperator StatementSuite
         | StatementSuite .


(* FEED SENTENCE *) 

FeedSentence = FEED FunctionName [ GenericTypes ] ProcParameters ( GuardsSuite | ProcBody ) .


(* FMAP SENTENCE *) 

FmapSentence = FMAP FunctionName [ GenericTypes ] ProcParameters [ "=>>" ProcResults ] ( GuardsSuite | ProcBody ) .


(* SUB SENTENCE *)

SubSentence = SUB SymbolIdentifier ProcParameters [ ProcResults ] ProcBody .


(* EVENT SENTENCE *)

EventSentence = EVENT SymbolIdentifier EventParameters [ ProcResults ] ProcBody .

EventParameters = "[" [ ParmDeclares ] "]" .


(* ENUM SENTENCE *)

EnumSentence = ENUM SymbolIdentifier [ GenericTypes ] [ GenericTypes ] ProcParameters [ MixinSentence ] EnumBody .

EnumBody = EOL Indent EnumMemberDeclaresList Dedent
         | ":" EnumMemberDeclares .

EnumMemberDeclaresList = EnumMemberDeclares { EOL EnumMemberDeclares } .

EnumMemberDeclares = EnumMemberDeclare { "," EnumMemberDeclare } .

EnumMemberDeclare = MixinSentence
                  | CompositeEnumerationDeclare
                  | TopLevelSentence
                  | CompositeAttributeDeclare
                  | CompositeMethodDeclare .

CompositeEnumerationDeclare = SymbolIdentifier [ EnumArguments ] [ "=" Expression ] .

EnumArguments = "(" Expressions ")" .


(* STRUCT SENTENCE *)

StructSentence = STRUCT SymbolIdentifier [ GenericTypes ] [ MixinSentence ] StructBody .

StructBody = EOL Indent StructMemberDeclaresList Dedent
           | ":" StructMemberDeclares .

StructMemberDeclaresList = StructMemberDeclares { EOL StructMemberDeclares } .

StructMemberDeclares = StructMemberDeclare { "," StructMemberDeclare } .

StructMemberDeclare = MixinSentence
                    | TopLevelSentence
                    | CompositeAttributeDeclare
                    | CompositeMethodDeclare .

CompositeAttributeDeclare = SymbolIdentifiers Type [ AttributeTag ] [ "=" Expressions ]
                          | SymbolIdentifier [ ArraySize ] STRUCT StructBody .

AttributeTag = StringLiteral .

CompositeMethodDeclare = SymbolIdentifier ProcParameters [ ProcResults ] ProcBody .


(* PROTO SENTENCE *)

ProtoSentence = PROTO SymbolIdentifier [ GenericTypes ] [ Implements ] ProtoBody .

ProtoBody = EOL Indent ProtoMethodDeclaresList Dedent
          | ProtoMethodDeclares .

ProtoMethodDeclaresList = ProtoMethodDeclares { EOL ProtoMethodDeclares } .

ProtoMethodDeclares = ProtoMethodDeclare { "," ProtoMethodDeclare } .

ProtoMethodDeclare = AbstractMethodDeclare .

AbstractMethodDeclare = SymbolIdentifier ProcParameters [ ProcResults ] .


(* TRAIT SENTENCE *)

TraitSentence = TRAIT SymbolIdentifier [ GenericTypes ] [ Implements | MixinSentence ] TraitBody .

TraitBody = EOL Indent TraitMemberDeclaresList Dedent
          | TraitMemberDeclares .

TraitMemberDeclaresList = TraitMemberDeclares { EOL TraitMemberDeclares } .

TraitMemberDeclares = TraitMemberDeclare { "," TraitMemberDeclare } .

TraitMemberDeclare = MixinSentence
                   | TopLevelSentence
                   | CompositeAttributeDeclare
                   | CompositeMethodDeclare
                   | CompositeEventDeclare .


(* CLASS SENTENCE *)

ClassSentence = CLASS SymbolIdentifier [ GenericTypes ] [ Extends ] [ Implements ] [ MixinSentence ] ClassBody .

Extends = SubtypeOperator Type .

Implements = SubtypeOperator Types .

ClassBody = EOL Indent ClassMemberDeclaresList Dedent
          | ":" ClassMemberDeclares .

ClassMemberDeclaresList = ClassMemberDeclares { EOL ClassMemberDeclares } .

ClassMemberDeclares = ClassMemberDeclare { "," ClassMemberDeclare } .

ClassMemberDeclare = MixinSentence 
                   | TopLevelSentence
                   | CompositeAttributeDeclare 
                   | AbstractMethodDeclare
                   | CompositeMethodDeclare
                   | CompositeEventDeclare .

CompositeEventDeclare = SymbolIdentifier EventParameters [ ProcResults ] ProcBody .


(* ------------------------------------------------------------------------- *)


(* RUBBER DUCK DEBUGGING *)

RubberDuck = UnicodeAtom { Alphanumeric } "=" .

DebuggingStatement = RubberDuck [ Statement ] .


(* SONGBIRD TRACING *)

SongBird = UnicodeAtom [ LoggingLevel | { Alphanumeric } ] ">" .

LoggingLevel = TRACE | DEBUG | INFO | WARN | ERROR | FATAL .

TracingStatement = SongBird [ Statement ] .


(* STATEMENTS AND BLOCKS *)

StatementSuite = "(" StatementSuite ")"
               | EOL Indent StatementBlock Dedent
               | ":" Statement .

StatementBlock = Statement { EOL Statement } .

Statement      = "(" Statement ")"
               | AtomStereotypes Statement
               | Statement CommandThreadOperator Statement 
               | Label Statement
               | ExpressionStatement
               | EmptyStatement
               | ControlFlowStatement
               | ConditionalStatement
               | LoopingStatement
               | IterationStatement
               | ControlTransferStatement
               | ErrorHandlingStatement
               | ConcurrencyStatement
               | TopLevelSentence
               | DebuggingStatement
               | TracingStatement
               | CommentedStatement .

Label = Identifier ":" .

ExpressionStatement = Expressions .

EmptyStatement = EllipsisOperator .


(* CONTROL FLOW STATEMENTS *)

ControlFlowStatement = DeferSentence
                     | WithSentence
                     | OrElseSentence .

DeferSentence = DEFER ( Statement | StatementSuite ) .

(* WITH SENTENCE *)

WithSentence = WITH Expressions StatementSuite.

(* ORELSE SENTENCE *)

OrElseSentence = Statement ORELSE ( Statement | StatementSuite ) .


(* CONDITIONAL STATEMENTS *)

ConditionalStatement = IfSentence
                     | UnlessSentence
                     | MatchSentence
                     | TrySentence .

(* IF-ELSE SENTENCE *)

IfSentence = IfThenClause | IfElseClause .

IfThenClause = IF Expression THEN Statement .

IfElseClause = IfClause
             { ElifClause }
             [ ElseClause ] .

IfClause = IF Expression StatementSuite .

ElifClause = ELIF Expression StatementSuite .

ElseClause = ELSE StatementSuite .

(* UNLESS SENTENCE *)

UnlessSentence = UnlessClause .

UnlessClause = Statement UNLESS Expression .

(* CASE-ELSE SENTENCE *)

CaseSentence = 
               [ ElseClause ] .

CaseClause = CASE Expression StatementSuite
             { CASE Expression StatementSuite } .

(* MATCH-LIKE-ELSE SENTENCE *)

MatchSentence = MatchClause
                CaseClauses
                [ ElseClause ] .

MatchClause = MATCH Expression [ EOL ] .

CaseClauses = CaseClause
            { CaseClause } .

CaseClause = Expressions StatementSuite .


(* TRY-CATCH SENTENCE *)

TrySentence = TryClause 
              CatchClause
              { EOL CatchClause } .

TryClause = TRY ( Statement | StatementSuite ) .

CatchClause = CATCH [ VarDeclares ] StatementSuite . 


(* LOOPING STATEMENTS *)

LoopingStatement = LoopSentence .

(* LOOP SENTENCE *)

LoopSentence = LOOP ( LoopSequence | LoopBlock ) .

LoopSequence = Statement [ LoopCheckFirst ] .

LoopBlock = [ LoopCheckFirst ] [ StepClause ] StatementSuite
          | StatementSuite [ LoopCheckLast ] [ StepClause ] .

LoopCheckFirst = LoopTimesClause | LoopForEachClause | LoopWhileClause | LoopUntilClause .

LoopCheckLast = LoopWhileClause | LoopUntilClause .

LoopTimesClause = TIMES Expression .

LoopForEachClause = FOR Identifiers .

LoopWhileClause = WHILE Expression .

LoopUntilClause = UNTIL Expression .

StepClause = STEP ( Expression | statement ) .


(* ITERATION STATEMENTS *)

IterationStatement = NextSentence 
                   | RedoSentence
                   | BreakSentence
                   | RetrySentence .

NextSentence = NEXT [ Label ] .

RedoSentence = REDO [ Label ] .

BreakSentence = BREAK [ Label ] .

RetrySentence = RETRY [ Label ] [ Expression ] .


(* CONTROL TRANSFER STATEMENTS *)

ControlTransferStatement = FallthroughSentence
                         | ContinueSentence
                         | ReturnSentence
                         | YieldSentence .

FallthroughSentence = FALLTHROUGH [ Label ] .

ContinueSentence = CONTINUE [ Label ] .

ReturnSentence = RETURN [ Expressions ] .

YieldSentence = YIELD Expressions .


(* ERROR HANDLING STATEMENTS *)

ErrorHandlingStatement = InvarSentence .

InvarSentence = INVAR [ SymbolIdentifier ] GuardsExpressions .


(* CONCURRENCY STATEMENTS *)

ConcurrencyStatement = DoSentence
                     | GoToSentence
                     | AwaitSentence
                     | SwitchSentence .

(* DO SENTENCE *)

DoSentence = DO ( DoSequence | StatementSuite ) .

DoSequence = Statement [ ( IF | UNLESS ) Expression ] .

(* GO TO STATEMENT *)

GoToSentence = ( ConcurrencySingleProcess | ConcurrencyBatchProcess ) [ ( TO | SET ) Expression ] .

ConcurrencySingleProcess = GO [ ForksNumber ] ConcurrencyProcess Coroutine .

ConcurrencyBatchProcess = GO [ ForksNumber ] FOR Identifiers EACH BatchData GoBody .

GoBody = EOL Indent GoProcessList Dedent .

GoProcessList = GoProcess EOL { GoProcess } .

GoProcess = ConcurrencyProcess Coroutine .

ForksNumber = Expression .

ConcurrencyProcess = ASYNC | THREAD | TASK | NODE .

Coroutine = Expression .

BatchData = Expression .

(* AWAIT STATEMENT *)

AwaitSentence = AWAIT [ Expressions | ALL ] [ TillCmd ] .

(* SWITCH-WHEN-DEFAULT STATEMENT *)

SwitchSentence = SwitchClause
                 WhenClause
                 [ DefaultClause ] .

SwitchClause = SWITCH Expressions [ EOL ] .

WhenClause = WHEN Expressions StatementSuite
             { WHEN Expressions StatementSuite } .

DefaultClause = DEFAULT StatementSuite .


(* ------------------------------------------------------------------------- *)


(* TYPES *)

Type = DecoratedType | ParameterizedType | TypeDeclare | TypeExpression | TypeLiteral | TypeName .

DecoratedType = [ PrefixTypeModifier ] Type [ PosfixTypeModifier ] .

ParameterizedType = Type [ GenericTypes ] . 

TypeDeclare = Types Type.

TypeExpression = Type ( "&" | "|" ) Type .

TypeLiteral = ArrayLiteralType | CompositeLiteralType | FactType | FunctionType | EventType .

TypeName = Identifier | NamespaceIdentifier .

GenericTypes = "<" Types ">" .   // TypeParameters

Types = Type { "," Type } .

(* Arrays *)

ArrayLiteralType = [ ArraySize ] ( ArrayType | ElementType ) .

ArrayType = ParameterizedType . (* array, list, dict, chan, tup, vec, mat, set, que, deq, xml, tab, mem *) 

ElementType = Type .

ArraySize = "[" Expression | RationalLiteral "]" .

(* Composites *)

CompositeLiteralType = ParameterizedType . (* Structs, Protos, Classes *)

(* Facts *)

FactType = FACT FactParameters . 

(* Functions *)

FunctionType = FUNC ProcParameters ProcResults .

(* Events *)

EventType = EVENT EventParameters ProcResults .

(* COMPOUND LITERALS *)

CompoundLiteral = ArrayLiteral | CompositeLiteral .

(* Arrays *)

ArrayLiteral = [ ArrayLiteralType ] ArrayLiteralValue
               | ArrayAosToSoaLiteral 
               | XmlLiteral | ListComprehension.

ArrayLiteralValue = "[" { Element [ "," ] } "]" | "[" "]" .

Element = [ ElementKey ":" ] ElementValue . 

ElementKey = Expression | EscalarLiteral .

ElementValue = Expression | Literal .

ArrayAosToSoaLiteral = "[" "]" Expression .

ListComprehension = "[" Expressions { ComprehensionClause } "]" .

(* Structs *)

CompositeLiteral = [ CompositeLiteralType ] CompositeLiteralValue .  

CompositeLiteralValue = "{" { FieldValue [ "," ] } EOL TraitBody "}" | "{" "}" | "{" "0" "}" .

FieldValue = Identifier [ FieldType ] ":" Literal . 


(* NEOBASIC NATIVE DATA TYPES *)

NeoNativeType = SymbolType | EscalarType | CompoundType | MetaType | ShellType .

EscalarType = BooleanType | NumericType | TemporalType | CharacterType | SequenceType .

CompoundType = CompositeType | ArrayType | ShellType .


(* SYMBOL DATA TYPE *)

SymbolType = ATOM .


(* META DATA TYPES *)

MetaType = ATOM | AUTO | VOID
         | MODULE | INTERFACE
         | TYPE | FACT | MODIF
         | FUNC | SUB | EVENT 
         | ENUM | STRUCT
         | PROTO | TRAIT | CLASS .

ShellType = PATH | URI | INET .

(* BOOLEAN DATA TYPES *)

BooleanType = BOOL8 | BOOL16 | BOOL32 | BOOL64 | BOOL128 | BOOL .


(* NUMERIC DATA TYPES *)

NumericType = NumericDigit | NumericNatural | NumericInteger
            | NumericDecimal | NumericReal | NumericRatio
            | NumericComplex | NumericQuaternion .

NumericDigit = DIG | BIT | OCT | HEX | NIBBLE | BYTE .

NumericNatural = NAT8 | NAT16 | NAT32 | NAT64 | NAT128 | NAT | BIGNAT .

NumericInteger = INT8 | INT16 | INT32 | INT64 | INT128 | INT | BIGINT .

NumericReal = REAL16 | REAL32 | REAL64 | REAL128 | REAL | BIGREAL .

NumericDecimal = DEC1 | DEC2 | DEC3 | DEC4 | DEC5 | DEC6 | DEC7 | DEC8 | DECIMAL | MONEY | BIGDECIMAL .

NumericRatio = RATIO8 | RATIO16 | RATIO32 | RATIO64 | RATIO128 | RATIO .

NumericComplex = COMPLEX16 | COMPLEX32 | COMPLEX64 | COMPLEX128 | COMPLEX .

NumericQuaternion = QUATERN16 | QUATERN32 | QUATERN64 | QUATERN128 | QUATERN . 


(* TEMPORAL DATA TYPES *)

TemporalType = DATE | ELAPSE .


(* CHARACTER DATA TYPES *)

CharacterType = ASCII | CHAR8 | CHAR16 | CHAR32 | CHAR | WCHAR .


(* SEQUENTIAL DATA TYPES *)

SequenceType = ANSI | STR8 | STR16 | STR32 | STR | REGEX | BINARY .


(* SHELL DATA TYPES *)

ShellType = PATH | URI | INET .


(* COMPOSITE DATA TYPES *)

CompositeType = RANGE | MAP .


(* ARRAY DATA TYPES *)

ArrayType = ARRAY | LIST | DICT | CHAN | TUPLE | VEC | MAT | TSET | QUEUE | DEQUE | XML | TABLE | MEMO . 


(* MONAD VALUE CONSTRUCTORS *)

MonadValue = BooleanData | NumericData | TemporalData | CharacterData | SequenceData
           | MaybeOption | EitherOption | StreamOption | ResultOption .

BooleanData = TRUE | FALSE .

NumericData = NONZERO | ZERO | MINVALUE | MAXVALUE | NAN | POSITIVEINFINITY | NEGATIVEINFINITY .

TemporalData = LOCALDATE | LOCALDATETIME | OFFSETDATE | OFFSETDATETIME | ZONEDDATE | ZONEDDATETIME
             | TOMORROW | TODAY | NOW | YESTERDAY | EON | EPOCH .

CharacterData = LETTER | MARK | DIGIT | PUNCTUATION | SYMBOL | SEPARATOR | NONPRINTABLE | NULL .

SequenceData = BLANK | NONBLANK .

PathData = FOLDER | FILE | LINKLINKFILE | PIPEFILE | SOCKETFILE
         | BLOCKDEVICE | CHARDEVICE | NULLDEVICE .

UriData = URL | URN .

InetData = IPV4 | IPV6 .

MaybeOption = SOME | NONE .

EitherOption = YEA | NAY .

StreamOption = DATA | EOT .

ResultOption = OKAY | FAIL .


(* ------------------------------------------------------------------------- *)


(* EXPRESSIONS *)

Expression = UnaryExpression | BinaryExpression | LetExpression | GetExpression | FactExpression
           | EagerEvaluateExpression | CondicionalExpression | FunctorExpression .

Expressions = Expression { "," Expression } .

JuxtapositionExpression = Expression { Expression } .

PredeclaredValue = THIS | IOTA | NTH | TOP | END | IT | SELF | SUPER.

FactScope = ALL | ANY | ONE | TWO | NIL .

Literal = EscalarLiteral | CompoundLiteral | LambdaLiteral .

BinaryExpression = Expression BinaryOperator Expression .

AssignmentExpression = Identifiers AssignmentOperator Expressions
                     | Identifier HeredocLiteral .

LetExpression = LET Expression .

GetExpression = GET Expression Expression .

FactExpression = [ FactScope "`" ] Identifier Expressions
               | Expression IS [NOT] [ FactScope "`" ] Identifier .

EagerEvaluateExpression = UnaryEvaluate "(" Expression ")" .

UnaryExpression = PrimaryExpression 
                | PrefixUnaryOperator UnaryExpression 
                | UnaryExpression PosfixUnaryOperator .

FactIdentifier  = Identifier | NamespaceIdentifier .

PrimaryExpression = Operand
                  | Operand ";" Modifier 
                  | Conversion
                  | MethodExpression
                  | PrimaryExpression Selector
                  | PrimaryExpression Indexing
                  | PrimaryExpression Slicing
                  | PrimaryExpression FunctionArguments [ ErrorHandling ]
                  | PrimaryExpression [ FunctionArguments ] LambdaLiteral [ ErrorHandling ] .

Operand = Literal | PredeclaredValue | OperandName [ GenericTypes ] | ShellExpression | "(" Expression ")" .

OperandName = Identifier | NamespaceIdentifier .

Modifier = Identifier .

Conversion = Expression ";" Type .

MethodExpression = ReceiverType "." MethodName .

ReceiverType = Type .

MethodName = Identifier .

Selector = "." Identifier .

Indexing = "[" Expression [ "," ] "]" .

Slicing = "[" SlicingRange [ ";" Expression ] "]" .

SlicingRange = [ Expression [ ">" ] ] ".." [ [ "<" ] Expression ] [ ":" Expression ] .

FunctionArguments = "(" [].

FunctionArguments = "(" [ NamedExpressionList [ "," ] ] ")" .

NamedExpressionList = [ Identifier "=" ] Expression { "," [ Identifier "=" ] Expression } .

ErrorHandling = "!"  [ Expression ] 
              | "!!" Expression
              | "!?" Expression
              | "?"
              | "??" Expression .

CondicionalExpression = IfExpression | UnlessExpression | ForGuardExpression .

IfExpression = Expression IF Expression ELSE Expression .

UnlessExpression = Expression UNLESS Expression ELSE Expression .


FunctorExpression = ForLambdaExpression | ForGuardExpression | ForPipelineExpression .

ForLambdaExpression = FOR [ Expressions ] LambdaLiteral .


ForPipelineExpression = FOR [ Expressions ] PipelinesExpressions .

PipelinesExpressions = { PipelineOperator Expression }+ .


ForGuardExpression = FOR [ Expressions ] GuardsExpressions .

GuardsExpressions = "|" GuardExpression { "|" GuardExpression  } [ "|" Expression ] .

GuardExpression = Expressions LambdaImpliesOperator Expression .


(* UNARY OPERATORS *)

UnaryBoolean    = NOT . (* Logical NOT *)

UnaryEvaluate   = "&" . (* Eager Expression or Memory address of a var *)

UnaryArithmetic = "+"  /* Plus sign */
                | "-"  /* Minus sign */
                | "**" /* Square power */
                | "*/" /* Square root */
                | "*!" /* Factorial */
                | "++" /* Increment of a var */
                | "--" /* Decrement of a var */ 
                .

UnaryBitwise    = "~"  /* Bitwise negation */
                | "~~" /* Bitwise negation of a var */
                .

UnarySort       = "^"  /* Sort ascending or descending a data structure */
                | "^^" /* Sort ascending or descending a var */
                .

UnarySpread     = "..." . (* Spread *)

UnaryClone      = "="   /* Shallow copy */
                | "===" /* Deep copy */
                .

UnaryMeta = TYPEOF     /* Type (string) of a var */
          | SIZEOF     /* Number of bytes required for a var or data structure */
          | INSTANCEOF /* Check if an object is an instance of a class */
          .

UnaryArray = EACH       /* Generate an iterator of a iterable var (for loops),
                           or a value converted to text, if not iterable,
                           Generate pipeline with itens of an array */
           | NEW        /* Insert a new item (before other) in a data structure or space in a string */
           | DEL        /* Delete an item of a data structure or a char of a string */
           .

PrefixUnaryOperator  = UnaryBoolean | UnaryEvaluate | UnaryArithmetic | UnaryBitwise
                     | UnarySort | UnarySpread | UnaryMeta | UnaryArray .

PosfixUnaryOperator = UnarySort | UnaryClone .


(* BINARY OPERATORS *)

ArithmeticExpOperator = "**" /* Nth power */
                      | "*/" /* Nth root */
                      .

ArithmeticMultOperator = "*"  /* Multiplication of numbers and strings */
                       | "/"  /* Real Division of numbers, join of paths */
                       | "\\" /* Quotient (Integer division of numbers) */
                       | "%"  /* Remainder (Integer division of numbers) */
                       .

ArithmeticAddOperator = "+" /* Addition of numbers, interpolation of strings */
                      | "-" /* Subtraction */
                      .

PercentageOperator = "%/" /* Percentage Calculation */
                   | "%*" /* Percentage Application */
                   | "%+" /* Percentage Increase */
                   | "%-" /* Percentage Decrease */
                   | "%^" /* Percentage Variation */
                   .

EllipsisOperator = "..." .

BitwiseShiftOperator = "<<"  /* Left shift */
                     | ">>"  /* Right shift */
                     | ">>>" /* Unsigned right shift */
                     .

BitwiseMultOperator = "&"  /* Bitwise AND */
                    | "&~" /* Bitwise bitclear (AND NOT) */
                    .

BitwiseAddOperator = "|" /* Bitwise OR */
                   | "^" /* Bitwise XOR */
                   .

ComparisonOperator = "<=>" /* Three-way comparison */
                   | "?:"  /* Elvis comparison */
                   .

ConcatenationOperator = "." . (* String concatenation *)

RelationalOperator = "==" /* Equality */
                   | "!=" /* Inequality */
                   | "<"  /* Less than */
                   | "<=" /* Less than or equal */
                   | ">"  /* Greater than */
                   | ">=" /* Greater than or equal */
                   .

BinaryBoolean   = AND   /* Logical AND */
                | OR    /* Logical OR */
                | XOR   /* Logical XOR */
                | NAND  /* Logical NAND */
                | NOR   /* Logical NOR */
                | NXOR  /* Logical NXOR */ 
                .

ConditionalOperator = IS        /* Identity Operator */
                    | IN        /* Membership Operator */
                    | BETWEEN   /* Range Operator */
                    | LIKE      /* Pattern Match Operator */
                    | "?%"      /* Evenly Divisible comparison */
                    | "!%"      /* Not Divisible comparison */
                    .

CoalescingOperator = "!!" /* Error coalescing */
                   | "??" /* Exception coalescing */
                   .

PipelineOperator = "|>" . (* Pipeline sequence *)

MonadBindOperador = "=>>" .

FunctorInfixOperador = "`" .

BinaryOperator  = ArithmeticExpOperator | ArithmeticMultOperator | ArithmeticAddOperator
                | PercentageOperator | EllipsisOperator
                | BitwiseShiftOperator | BitwiseMultOperator | BitwiseAddOperator
                | ComparisonOperator | ConcatenationOperator
                | RelationalOperator | BinaryBoolean   | ConditionalOperator
                | CoalescingOperator | PipelineOperator
                | MonadBindOperador | FunctorInfixOperador .


(* ASSIGNMENT OPERATORS *)

SingleAssignmentOperator = "="   /* Simple assignment */
                         | ":="  /* Destructuring assignment  */
                         | "<-"  /* Pop-one assignment */
                         | "<<-" /* Pull-all assignment */
                         | "<|"  /* Pipe assignment */
                         .

CompoundAssignmentOperator = "**="  /* Nth power Compound assignment */
                           | "*/="  /* Nth root Compound assignment */
                           | "*="   /* Multiplication Compound assignment */
                           | "/="   /* Real Division Compound assignment */
                           | "%%="  /* Quotient Compound assignment */
                           | "÷="   /* Quotient Compound assignment */
                           | "%="   /* Remainder Compound assignment */
                           | "+="   /* Addition Compound assignment */
                           | "-="   /* Subtraction Compound assignment */
                           | "%+="  /* Percentage Increase Compound assignment */
                           | "%-="  /* Percentage Decrease Compound assignment */
                           | "<<="  /* Left shift Compound assignment */
                           | ">>="  /* Right shift Compound assignment */
                           | ">>>=" /* Unsigned right shift Compound assignment */
                           | "&="   /* Bitwise AND Compound assignment */
                           | "&^="  /* Bitwise bit Cancel (AND NOT) Compound assignment */
                           | "^="   /* Bitwise XOR Compound assignment */
                           | "|="   /* Bitwise OR Compound assignment */
                           | ".="   /* String concatenation Compound assignment */
                           .

AssignmentOperator = SingleAssignmentOperator | CompoundAssignmentOperator .


(* IMPLICATION OPERATORS *)

NeckRule = ":-" .

MixinOperator = "<>" . (* Mixin, in composition, operator *)

SubtypeOperator = "->" . (* Subtype / Extends operator *)

LambdaImpliesOperator = "=>" . (* Lambda Implies operator | Implicit return *)


(* PREFIX SYMBOL MODIFIERS *)

VisibilityModifier   = "+" /* Public visibility */
                     | "~" /* Package (or default) visibility */
                     | "-" /* Private visibility */
                     .

LifetimeModifier     = "*" . (* Resource variable Lifetime *)

DerivedModifier      = "/" . (* Derived attribute *)

ReferenceModifier    = "&" . (* Borrowed / pass-by-reference parameter *)

VariadicModifier   = "..." . (* Variadic variable declaration *)

SliceModifier      = ".." . (* Slice array declaration *)

PrefixSymbolModifier = VisibilityModifier | LifetimeModifier | DerivedModifier | VariadicModifier | SliceModifier .

PrefixParmModifier   = ReferenceModifier .


(* PREFIX TYPE MODIFIERS *)

ArrayModifier = "[" [ Expression ] "]" . (* Array variable declaration *) 

PrefixTypeModifier = ArrayModifier .


(* POSFIX TYPE MODIFIERS *)

OptionalModifier       = "!"   /* ResultOption wrapper declaration */
                       | "?"   /* MaybeOption  wrapper declaration */
                       | "??"  /* EitherOption wrapper declaration */
                       | "|>"  /* StreamOption wrapper declaration */
                       | "!?"  /* ResultOption wrapper of MaybeOption wrapper declaration */
                       | "!??" /* ResultOption wrapper of EitherOption wrapper declaration */
                       | "!|>" /* ResultOption wrapper of StreamOption wrapper declaration */
                       .  

ShallowInitialModifier = "=" | "===".

PosfixTypeModifier     = OptionalModifier | ShallowInitialModifier .


(* MULTITHREAD CONTROL FLOW *)

CommandSequence     = "&&" .
CommandSequenceOkay = "?&" .
CommandSequenceFail = "!&" .
CommandBackground   = "|&" .

OutputRedirection       = "&>" .
AppendOutputRedirection = "&>>" .

StdoutRedirection       = "&1>" .
AppendStdoutRedirection = "&1>>" .

StderrRedirection       = "&2>" .
AppendStderrRedirection = "&2>>" .

CommandThreadOperator = CommandSequence
                      | CommandSequenceOkay
                      | CommandSequenceFail
                      | CommandBackground
                      | OutputRedirection
                      | AppendOutputRedirection
                      | StdoutRedirection
                      | AppendStdoutRedirection
                      | StderrRedirection
                      | AppendStderrRedirection
                      .


(* ------------------------------------------------------------------------- *)


(* LAMBDA FUNCTION LITERALS *)

LambdaLiteral = "(\\" LambdaBody ")" .

LambdaBody = [ LambdaParmDeclares LambdaImpliesOperator ] ( Statement | StatementSuite ) . 

LambdaParmDeclares = LambdaParmDeclare { "," LambdaParmDeclare } .

LambdaParmDeclare = Identifiers [ Type ] .


(* XML ARRAY LITERALS *)

XmlElement = "<" XmlTagName [ XmlAttributes ] ">" [ XmlChildren ] "</" XmlTagName ">"
           | "<" XmlTagName "/>" .

XmlTagName = Identifier .

XmlAttributes = { WSP Identifier [ "=" Expression ] } .

XmlChildren = { XmlElement | StringMultiValue } .

XmlLiteral = XmlElement .


(* ESCALAR LITERALS *)

NumericLiteral = NumberLiteral | IntegerLiteral | RealLiteral | DecLiteral
               | ImaginaryLiteral | RationalLiteral . 

RangeLiteral = Expression [ ">" ] ".." [ "<" ] Expression  [ ":" Expression ].

MapLiteral = Expression ":" Expression .

ArithmeticComprehension = BinaryOperator "{" Expressions { ComprehensionClause } "}" .

ComprehensionClause = LoopForEachClause [ IF Expression ] .

EscalarLiteral = NumericLiteral | RangeLiteral | MapLiteral
               | AsciiLiteral | UnicodeLiteral | StringLiteral | VerbatimLiteral | RegexLiteral
               | XmlElement | AtomLiteral | PromptLiteral | ArithmeticComprehension .


(* UNSIGNED AND SIGNED INTEGER LITERALS *) 

DecimalInteger = DecimalGroups .
BinaryInteger  = "0" ( "b" | "B" ) [ "_" ] BinaryGroups .
OctalInteger   = "0" [ "o" | "O" ] [ "_" ] OctalGroups .
HexInteger     = "0" ( "x" | "X" ) [ "_" ] HexGroups .
RomanInteger   = "0" ( "r" | "R" ) [ "_" ] RomanGroups .

NumberLiteral = ( DecimalInteger | BinaryInteger | OctalInteger | HexInteger | RomanInteger ) . 

IntegerLiteral = [ "+" | "-" ] NumberLiteral . 


(* FIXED-POINT AND FLOATING-POINT REAL LITERALS *)

DecimalPoint    = "." .

DecimalMantissa = DecimalGroups DecimalPoint [ DecimalGroups ]
                | DecimalPoint DecimalGroups
                | DecimalGroups .
DecimalExponent = ( "e" | "E" ) [ "+" | "-" ] DecimalGroups .
DecimalReal     = DecimalMantissa [ DecimalExponent ] .

HexMantissa     = [ "_" ] HexGroups DecimalPoint [ HexGroups ]
                | [ "_" ] HexGroups
                | "." HexGroups .
HexExponent     = ( "p" | "P" ) [ "+" | "-" ] DecimalGroups .
HexReal         = "0" ( "x" | "X" ) HexMantissa HexExponent .

DecLiteral      = [ "+" | "-" ] DecimalMantissa .

RealLiteral     = [ "+" | "-" ] ( DecimalReal | HexReal ) . 


(* IMAGINARY LITERALS *)

ImaginaryUnit    = "i" | "j" | "k" .
ImaginaryLiteral = ( IntegerLiteral | RealLiteral ) ImaginaryUnit .


(* RATIONAL LITERALS *)

RationalLiteral = IntegerLiteral "//" IntegerLiteral .


(* ASCII CHARACTER LITERALS *)

AsciiEscapedControl  = "\\" ( "0" /* 0x00 NULL (NUL) */
                            | "a" /* 0x07 Bell (BEL) */
                            | "b" /* 0x08 Backspace (BS) */
                            | "c" /* 0x03 End of Text (ETX) = Ctrl+C = SIGINT (Interrupt Signal) */
                            | "d" /* 0x04 End of Transmission (EOT) = Ctrl+D = EOF (End Of File) */
                            | "e" /* 0x1B Escape (ESC) */
                            | "f" /* 0x0C Form Feed (FF) */
                            | "n" /* 0x0A Line Feed (LF) */
                            | "q" /* 0x1C File Separator (FS) = Ctrl+\ = SIGQUIT (Quit Signal) */
                            | "r" /* 0x0D Carriage Return (CR) */
                            | "s" /* 0x20 White Space (SP) */
                            | "t" /* 0x09 Horizontal Tab (HT) */
                            | "v" /* 0x0B Vertical Tab (VT) */
                            | "z" /* 0x1A Substitute (SUB) = Ctrl+Z = SIGTSTP (Terminal Stop Signal) */
                            ) .

AsciiEscapedSequence = "\\" ( '"' /* 0x22 Double Quote */
                            | "'" /* 0x27 Single Quote */
                            | "\\" /* 0x5C Backslash */
                            | "`" /* 0x60 Backtick */
                            ) .
AsciiEscapedDecimal = "\\" DecimalDigit DecimalDigit DecimalDigit .
AsciiEscapedBinary  = "\\" "b" BinaryDigit BinaryDigit BinaryDigit BinaryDigit 
                              BinaryDigit BinaryDigit BinaryDigit BinaryDigit .
AsciiEscapedOctal   = "\\" "o" OctalDigit OctalDigit OctalDigit .
AsciiEscapedHex     = "\\" "x" HexDigit HexDigit .

AsciiValue   = AsciiPrintable | AsciiEscapedControl | AsciiEscapedSequence
             | AsciiEscapedDecimal | AsciiEscapedBinary | AsciiEscapedOctal | AsciiEscapedHex .

AsciiLiteral = NumberLiteral     
             | "'" AsciiValue "'"
             | '"' AsciiValue '"' .


(* UNICODE CHARACTER LITERALS *)

UnicodeEscapedShort = "\\" "u" HexDigit HexDigit HexDigit HexDigit .
UnicodeEscapedLong  = "\\" "U" [ HexDigit HexDigit ] HexDigit HexDigit 
                                HexDigit HexDigit   HexDigit HexDigit .

UnicodeEscaped = AsciiEscapedControl | AsciiEscapedSequence | AsciiEscapedDecimal
               | AsciiEscapedBinary | AsciiEscapedOctal | AsciiEscapedHex
               | UnicodeEscapedShort | UnicodeEscapedLong .

UnicodeValue   = UnicodePrintable | AsciiValue
               | UnicodeEscapedShort | UnicodeEscapedLong .

UnicodeLiteral = AsciiLiteral
               | "'" UnicodeValue "'"
               | '"' UnicodeValue '"' .


(* ASCII STRING & UNICODE TEXT LITERALS *)

StringPlaceholder  = "{" Expression [ ";" FormatSpecifiers ] "}" .
FormatSpecifiers   = UnicodeValue { UnicodeValue } .

StringSingleValue = { UnicodeValue | StringPlaceholder } .
StringMultiValue  = { UnicodeValue | StringPlaceholder | EOL } .

StringLiteral = ( "'" StringSingleValue "'" | "'''" StringMultiValue "'''" ) .


(* VERBATIM LITERALS *)

VerbatimSingleValue = { UnicodePrintable } .
VerbatimMultiValue  = { UnicodePrintable | EOL } .

VerbatimLiteral = '"' VerbatimSingleValue '"' | '"""' VerbatimMultiValue '"""' .


(* HEREDOC LITERALS *)

HeredocContent = "'" [ EOL ] StringMultiValue [ EOL ] "'" 
               | '"' [ EOL ] VerbatimMultiValue [ EOL ] '"' 
               | Identifier [ EOL ] VerbatimMultiValue [ EOL ] Identifier .

HeredocLiteral = "<<" HeredocContent .


(* REGULAR EXPRESSION LITERALS *)

RegexLiteral = "/" { UnicodeValue } "/" [ { UnicodeValue } ] . 


(* ATOM LITERALS *) 

AtomDotLiteral = UnicodeAtom IntegerLiteral { "." IntegerLiteral } .

AtomCsiLiteral = UnicodeAtom IntegerLiteral { "." IntegerLiteral } "." AsciiPrintable
               | UnicodeAtom AsciiPrintable . 

AtomMusicLiteral = UnicodeAtom MusicAlphabet { "." MusicAlphabet } .

AtomElapseLiteral = UnicodeAtom DotFractionValue { "." DotFractionValue } .

DotFractionValue = IntegerLiteral "." Identifier .

AtomLiteral = AtomDotLiteral | AtomCsiLiteral | AtomElapseLiteral | AtomMusicLiteral .


(* PROMPT LITERAL *)

PromptLiteral = UnicodeShell ( StringLiteral | VerbatimLiteral ) .


(* ------------------------------------------------------------------------- *)


(* IDENTIFIERS *)

Tag = Alphanumeric { Alphanumeric } .

Identifier = Letter { Alphanumeric } .

Identifiers = Identifier { "," Identifier } .

NamespaceIdentifier = Identifier { "." Identifier } .

AtomIdentifier = UnicodeAtom Identifier .

AspectIdentifier = UnicodeAtom UnicodeAtom Identifier .

ShellIdentifier = UnicodeShell Identifier .  /* Environment Variable */
	            |                 .

ShellLiteral = UnicodeShell "_"                 /* Current directory, workspace */
	         | UnicodeShell ("0" | "1" | "2")   /* Standard streams (stdin, stdout, stderr) */
	         | UnicodeShell "%"                 /* All the arguments in an array or string */
	         | UnicodeShell "%" DecimalInteger  /* Nth argument */
	         | UnicodeShell UnicodeShell        /* Process ID (PID) of the NeoBASIC program */
             | FileSystemShell
             | ShellIdentifier
             .

ShellExpression = ShellLiteral [ ';' Type ] .

ShellExpressions = ShellExpression { "," ShellExpression } .

SymbolIdentifier = AtomStereotypes SymbolIdentifier
                 | PrefixSymbolModifier SymbolIdentifier
                 | Identifier
                 | ShellIdentifier
                 | AtomIdentifier .

SymbolIdentifiers = SymbolIdentifier { "," SymbolIdentifier } .


(* FILE SYSTEM FILES AND DIRECTORIES LITERALS *)

FileSystemShell = UnicodeShell FileSystemPath .

FileSystemPath = AbsolutePath | RelativePath | TildePath .

AbsolutePath = ( "\\" | Letter ":\\" | PathSeparator ) Path .

RelativePath = ( "." PathSeparator  | ".." PathSeparator ) ( { ".." PathSeparator [ Path ] } | Path ) .

TildePath = "~" [ PathSeparator ] Path .

Path = File { PathSeparator File } .

File = PathChar { PathChar } . 

PathChar = UnicodeFilepath | UnicodeEscaped .

PathSeparator = "/" | "\\" . 


(* MUSICAL ALPHABET *) 

MusicAlphabet = MusicNote [ PitchFlat | PitchSharp ] [ OctaveDigit ] .

MusicNote = "A" … "G" .

PitchFlat = "f" .
PitchSharp = "s" .

OctaveDigit = "0" … "8" .


(* TOKENS *)

UnicodeAtom = "@" .

UnicodeShell = "$" .

UnicodeVerb = "%" .

Keyword = Letter { Letter } .


(* LETTERS AND DIGITS *)

Letter        = UnicodeLetter | "_" .
Alphanumeric  = Letter | UnicodeDigit .

DecimalDigit  = UnicodeDigit .
BinaryDigit   = "0" | "1" .
OctalDigit    = "0" … "7" .
HexDigit      = "0" … "9" | "A" … "F" | "a" … "f" .
RomanDigit    = "I"	| "V" | "X"	| "L" | "C"	| "D" | "M" .

DecimalGroups = DecimalDigit { [ "_" ] DecimalDigit } .
BinaryGroups  = BinaryDigit { [ "_" ] BinaryDigit } .
OctalGroups   = OctalDigit { [ "_" ] OctalDigit } .
HexGroups     = HexDigit { [ "_" ] HexDigit } .
RomanGroups   = RomanDigit { [ "_" ] RomanDigit } .


(* UNICODE CHARACTERS *)

AsciiChar   = /* Unicode code points from U+0000 to U+00FF */ .
UnicodeChar = /* Unicode code points from U+0000 to U+10FFFF */ .


(* UNICODE PRINTABLE CHARACTERS *)

UnicodeLetter = /* Unicode code point categorized as (L) Letter */ .
UnicodeDigit  = /* Unicode code point categorized as (Nd) Decimal Number */ .

AsciiPrintable   = (* Unicode code points from U+0000 to U+00FF,
                      except categorized as Cc (Control) *) .

UnicodePrintable = (* Unicode code points from U+0000 to U+10FFFF,
                      except categorized as Cc (Control), Cf (Format), 
                      Cs (Surrogate), Co (Private Use), Cn (Unassigned) *) .

UnicodeFilepath  = (* Unicode code points from U+0000 to U+10FFFF,
                      except categorized as Cc (Control), Cf (Format), 
                      Cs (Surrogate), Co (Private Use), Cn (Unassigned) 
                      and except these 11 chars   "/ \ | < > : ? * \" ' `"   *) . 


(* UNICODE END-OF-LINE AND END-OF-FILE SEPARATORS *) 

UnicodeEOT = /* Unicode code point U+0004 (EOT) End of Transmission Ctrl+D */ .
UnicodeLF  = /* Unicode code point U+000A (LF)  Line Feed */ .
UnicodeCR  = /* Unicode code point U+000D (CR)  Carriage Return */ .
UnicodeSUB = /* Unicode code point U+001A (SUB) Substitute Ctrl+Z */ .
UnicodeNEL = /* Unicode code point U+0085 (NEL) Next Line */ . 
UnicodeLS  = /* Unicode code point U+2028 (LS)  Line Separator */ . 
UnicodePS  = /* Unicode code point U+2029 (PS)  Paragraph Separator */ .

(* End-of-Line *)

EOL = UnicodeCR UnicodeLF /* Windows, DOS */
    | UnicodeLF           /* Unix, Linux, macOS */
    | UnicodeCR           /* Classic Mac OS (pre-OS X) */
    | UnicodeNEL          /* IBM Mainframes (EBCDIC) */
    | UnicodeLS           /* Unicode Line Separator */
    | UnicodePS           /* Unicode Paragraph Separator */
    .

(* End-of-File *)

EOF = UnicodeSUB (* Windows, DOS, Legacy only *)
    | UnicodeEOT (* Unix terminal input *)
    | EOL        (* End-of-Line *)
    .


(* UNICODE WHITE SPACE AND INDENTATION SEPARATORS *)

Indent = UnicodeSP UnicodeSP UnicodeSP UnicodeSP .

Dedent = UnicodeBS UnicodeBS UnicodeBS UnicodeBS .

WSP = UnicodeSP     (* White Space *)
    | UnicodeHT
    | UnicodeVT
    | UnicodeFF
    | UnicodeSpace
    | EOL
    .

UnicodeSP = /* Unicode code point U+0020 (SP) Space */ . 
UnicodeBS = /* Unicode code point U+0008 (BS) Backspace */ .

UnicodeHT = /* Unicode code point U+0009 (HT) Horizontal Tab */ .
UnicodeVT = /* Unicode code point U+000B (VT) Vertical Tab */ .
UnicodeFF = /* Unicode code point U+000C (FF) Form Feed */ .

UnicodeSpace = /* Unicode code point with Property White_Space="Yes",
                  except line break separators code points */ .

(* ------------------------------------------------------------------------- *)
